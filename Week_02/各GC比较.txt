1.串行GC
	Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代
收集器的唯一选择。这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明
它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，
必须暂停其他所有工作线程，直到它收集结束。STW是由虚拟机在后台自动发起和自动完成的，
在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。
但是串行GC在单核、小内存的系统中运行，性能要高于其他GC。

2.并行GC
	jdk8的默认gc，吞吐量优先。对新生代对象的拷贝（mark-copy）使用STW，
对老年代的Mark/Sweep/Compact（mark-sweep-compact）三步骤均采用STW实现，
无论新生代还是老年代，都是STW。它和ParallelOldGC的区别在于Compact也并发进行，而非串行进行。
其各目标的优先级分别是：1, 首先满足暂停时间目标；2, 满足吞吐量目标; 3, 最后考虑最小化堆大小。

3.CMSGC
	jdk1.5引入（jdk 14中彻底删除了cms，jdk 9标记为deprecated）。
并发标记（准确的说，又分为初始标记、并发标记、重新标记，第1、3通常需要STW）、清理收集器，响应时间优先。
其目标是尽可能对老年代的回收并发进行，并避免压缩，最小化延迟。但是一旦老年代碎片化太严重，压缩就需要STW。
新生代和ParallelGC一样，拷贝采用STW（在JDK9中被标记为过期，JDK14中移除）。

4.G1GC
	其目标是尽可能完全避免full gc，即老年代的STW，优先考虑暂停时间、其次才是吞吐量，所以更像是cms的升级版。
它是通过分块gc实现的，每块的大小可以通过-XX:G1HeapRegionSize设置，默认值根据堆初始和最大值自动计算，
确保大约有2048块左右，jvm启动的时候会在一开始打印出来。-G1PrintRegionLivenessInfo可打印每次标记后分块的大小和实际占用，
-G1PrintHeapRegions可在gc中输出分库的分配和回收情况。在分代上，不再那么的泾渭分明。但是和parallel gc一样，
一旦这些区域碎片太严重需要压缩，压缩仍然需要STW的方式完成，但是尽可能的避免了region内碎片的产生。
新生代和parallelgc以及cms一样，拷贝也需要STW。在jdk 9中被作为默认gc（OLTP下用于代替CMS效果可以），
而不是Parallel GC（吞吐量优先，但一定要设置并行gc数量，否则在大型服务器中负载会巨高），
因为g1 gc在回收前会先评估对哪些分块进行gc能够得到更高的回收率，因此整体而言，内存需求会比parallel gc要更高

5.ZGC
	jdk 11引入，适用于20GB以上内存（注意，最好不要一个JVM进程的堆分配超过32GB），
jdk 13开始支持释放未使用内存给操作系统。启用方法：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC，
-XX:ZUncommitDelay=<seconds>控制内存释放的阈值，我们使用它也是为了能够释放未使用内存给其他进程或JVM使用。